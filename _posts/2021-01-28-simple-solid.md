---
layout: post
title: solid principles ฉบับที่ตัวเองเข้าใจ
---

1. S - Single-responsibility principle คือ function หรือ class ควรรับผิดชอบอย่างเดียว อันนี้ก็ตรงไปตรงมา เช่น 
   ถ้าจะคำนวณก็คำนวณไป แล้วถ้าจะให้รูปแบบ (format) เป็น json หรือ xml ก็ทำฟังชั่นแยกไป
   
2. O - Open–closed principle คือ ปิดไม่ให้แก้ไขแต่สามารถเพิ่มความสามารถให้มันได้ เช่น 
   ฟังชั่นที่คำนวณผลลัพท์บางอย่างออกมาแล้วส่งค่ากลับมาเป็นรูปแบบ json ถ้าวันนึงเราต้องการให้เป็น xml ก็ควรทำได้ ได้ไม่ต้องแก้ไขฟังชั่นนี้ แต่อาจจะทำบางอย่างที่ไม่ต้องแก้ไขฟังชั่นนี้อีก ถ้าต้องการรูปแบบใหม่เป็น csv
   
3. L - Liskov substitution principle คือ อันนี้ใช้ในการสือทอด คือ ลูก และ แม่ ต้องไม่แตกต่างกัน เช่น 
   ไม่ใช่ แม่เป็น เป็ด พอ อยากได้ คลาส ลูก สืบทอดมา แต่ลูกเป็น เป็ดยาง อาจจะเป็ดเหมือนกัน แต่มันก็มีความต่างกันอยู่ หรือ พูดอีกนัยนึงคือคนรับ ควรรับได้ทั้งแม่และลูก
   
4. I - Interface segregation principle คือ ถ้าคนรับต้องการความสามารถแค่นี้ก็ควรทำ interface ที่มีเฉพาะความสามารถแค่นี้ เช่น 
   ฟังชั่ง A ต้องการแค่ play pause resume ก็ทำ interface แค่นี้ ไม่ต้องมี stop, rewind, replay หรืออะไร ที่ คนรับไม่ต้องการ
   
5. D - Dependency inversion principle คือ ไม่ควรยึดติดกับชนิด ควรรับเป็นพฤติกรรมแทน หรือ ไม่ควรรับเป็น type, class หรืออะไร รับเป็น interface แทน


สรุปแบบสั้น
1. ควรรับผิดชอบงานอย่างเดียว
2. เพิ่มความสามารถโดยไม่ต้องแก้ไขข้างใน
3. แม่ ลูก ควรจะเหมือนกัน เหมือนกันจริงๆ
4. ทำ interface ให้เล็กๆ เพื่อจะได้รับเฉพาะพฤติกรรมที่ต้องการ
5. ไม่ยืดติดกับชนิด ยึดติดกับพฤติกรรมแทน
